# ========================== SKRYPT 2: RASTRY (FIX 000523 + STABILIZACJA) ==========================
import os
import zipfile
import hashlib
import arcpy
from arcgis.gis import GIS
from arcgis.features import FeatureLayer
from arcgis.raster.utils import publish_hosted_imagery_layer
from datetime import datetime
import urllib3

# --- KONFIGURACJA ---
survey_item_id  = "6ebf85954a5d46e1aa6f7aac120c7764"
extent_layer_id = "b02d534c0723407496844b3483ef2dd6"
workspace       = r"/arcgis/home/pobrane_rastry"

# Kluczowa zmiana: użyj 102100 (Auxiliary Sphere), akceptuj też 3857 jako równoważny
spatial_ref     = arcpy.SpatialReference(102100)  # WGS_1984_Web_Mercator_Auxiliary_Sphere
_ACCEPTABLE_WKIDS = {102100, 3857}

# --- INICJALIZACJA ---
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
arcpy.env.overwriteOutput = True
arcpy.env.outputCoordinateSystem = spatial_ref  # <<< ważne
gis = GIS("home")
survey_layer = gis.content.get(survey_item_id).layers[0]
extent_layer = FeatureLayer(gis.content.get(extent_layer_id).layers[0].url)
os.makedirs(workspace, exist_ok=True)

# ---------- POMOCNICZE ----------
def _md5(path):
    h = hashlib.md5()
    with open(path, 'rb') as f:
        for chunk in iter(lambda: f.read(1<<20), b''):
            h.update(chunk)
    return h.hexdigest()

def _get_survey_oid_field_def():
    return next((f for f in extent_layer.properties.fields if f['name'].lower() == 'survey_oid'), None)

def _build_where_for_oid(oid):
    fdef = _get_survey_oid_field_def()
    if not fdef:
        raise RuntimeError("Brak pola 'survey_oid' w warstwie extentów.")
    return f"survey_oid = '{oid}'" if fdef['type'] == 'esriFieldTypeString' else f"survey_oid = {oid}"

def _ensure_extent_sr_3857(geom_json):
    """Zwraca extent w SR=102100/3857 jako (xmin,ymin,xmax,ymax)."""
    shp = arcpy.AsShape(geom_json, True)
    if shp.spatialReference is None or shp.spatialReference.factoryCode not in _ACCEPTABLE_WKIDS:
        shp = shp.projectAs(spatial_ref)
    ext = shp.extent
    return ext.XMin, ext.YMin, ext.XMax, ext.YMax

def _calc_stats_pyramids(ras_path):
    try:
        arcpy.management.CalculateStatistics(ras_path)
    except Exception:
        pass
    try:
        arcpy.management.BuildPyramids(ras_path)
    except Exception:
        pass

def _copy_to_geotiff(src, out_tif):
    """Stabilne zapisanie GeoTIFF: najpierw spróbuj CopyRaster, a gdyby się wywaliło – RasterToOtherFormat."""
    try:
        arcpy.management.CopyRaster(in_raster=src, out_rasterdataset=out_tif, format="TIFF")
        return out_tif
    except Exception as e1:
        # Fallback: RasterToOtherFormat zapisze do folderu (zachowa nazwę bez rozszerzenia)
        out_folder = os.path.dirname(out_tif)
        base_name  = os.path.splitext(os.path.basename(out_tif))[0]
        tmp_folder = os.path.join(out_folder, "_r2of_tmp")
        os.makedirs(tmp_folder, exist_ok=True)
        try:
            arcpy.conversion.RasterToOtherFormat(in_rasters=[src], out_folder=tmp_folder, raster_format="TIFF")
            # znajdź utworzony plik .tif i przenieś pod docelową nazwę
            candidates = [os.path.join(tmp_folder, f) for f in os.listdir(tmp_folder) if f.lower().endswith(".tif")]
            if not candidates:
                raise RuntimeError("RasterToOtherFormat nie zwrócił żadnego TIFF-a.")
            produced = candidates[0]
            # przenieś/zmień nazwę
            if os.path.exists(out_tif):
                try:
                    os.remove(out_tif)
                except Exception:
                    pass
            arcpy.management.CopyRaster(produced, out_tif, format="TIFF")
            return out_tif
        except Exception as e2:
            raise RuntimeError(f"CopyRaster i RasterToOtherFormat nie powiodły się: {e1} | {e2}")

def _embed_georef_with_tfw(src_tif, extent_xyxy, out_tif):
    """
    Jeśli raster ma SR ≠ Unknown → w razie potrzeby rzutuj do 102100/3857.
    Jeśli brak SR → zapisz world file (TFW) z extenta, DefineProjection(102100), a potem wypal GeoTIFF.
    Zwraca (ścieżka_do_finalnego_TIF, czy_była_ingerecja_bool).
    """
    dsc = arcpy.Describe(src_tif)
    sr  = dsc.spatialReference

    # Ma SR?
    if sr and sr.name != "Unknown" and getattr(sr, "factoryCode", 0) != 0:
        wkid = sr.factoryCode
        if wkid not in _ACCEPTABLE_WKIDS:
            proj = os.path.join(os.path.dirname(out_tif), "projected_102100.tif")
            arcpy.management.ProjectRaster(src_tif, proj, spatial_ref)
            _calc_stats_pyramids(proj)
            return proj, True
        # Jest już 102100/3857 → dla pewności kopiujemy do „czystego” GeoTIFF (często stabilniejsze do publikacji)
        copied = _copy_to_geotiff(src_tif, out_tif)
        _calc_stats_pyramids(copied)
        return copied, False

    # Brak SR → wylicz parametry z extenta i utwórz TFW
    xmin, ymin, xmax, ymax = extent_xyxy
    ras = arcpy.Raster(src_tif)
    cols, rows = ras.width, ras.height
    xres = (xmax - xmin) / cols
    yres = (ymax - ymin) / rows

    tfw = os.path.splitext(src_tif)[0] + ".tfw"
    with open(tfw, "w") as f:
        f.write(f"{xres}\n0.0\n0.0\n{-yres}\n{xmin}\n{ymax}\n")

    # Nadaj SR i wypal GeoTIFF
    arcpy.management.DefineProjection(src_tif, spatial_ref)
    cooked = _copy_to_geotiff(src_tif, out_tif)
    _calc_stats_pyramids(cooked)
    return cooked, True

def _query_extent_feature(oid):
    """Zwraca pierwszy feature z extent layer dla danego survey_oid (out_fields='*')."""
    where = _build_where_for_oid(oid)
    return extent_layer.query(where=where, out_fields="*", return_geometry=True)

def _update_fileid_for_oid(oid, viewer_url):
    q = extent_layer.query(where=_build_where_for_oid(oid), out_fields="*", return_geometry=False)
    if not q or not q.features:
        raise RuntimeError(f"Nie znaleziono wpisu w extentach dla OID={oid}")
    feat = q.features[0]
    feat.attributes["fileID"] = viewer_url
    res = extent_layer.edit_features(updates=[feat])
    ok = res.get("updateResults", [{}])[0].get("success", False)
    if not ok:
        err = res.get("updateResults", [{}])[0].get("error", {})
        raise RuntimeError(f"Błąd aktualizacji fileID: {err}")

# ---------- GŁÓWNA LOGIKA ----------
def process_feature(feature):
    oid = feature.attributes["objectid"]
    title_base = (feature.attributes.get("title") or f"Mapa_{oid}").replace(" ", "_")
    title = f"{title_base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    print(f"\nOID {oid}: Przetwarzanie...")

    # 1) Pobierz ZIP i rozpakuj
    atts = survey_layer.attachments.get_list(oid)
    zips = [a for a in atts if a["name"].lower().endswith(".zip")]
    if not zips:
        return f"OID {oid}: Brak ZIP-a."
    dl = survey_layer.attachments.download(oid, zips[0]["id"], workspace)
    zip_path = dl[0] if isinstance(dl, list) else dl

    work = os.path.join(workspace, f"oid_{oid}")
    os.makedirs(work, exist_ok=True)
    try:
        with zipfile.ZipFile(zip_path, 'r') as zf:
            zf.extractall(work)
    except Exception as e:
        return f"OID {oid}: Błąd rozpakowywania: {e}"

    # 2) Znajdź TIF
    tifs = [f for f in os.listdir(work) if f.lower().endswith((".tif", ".tiff"))]
    if not tifs:
        return f"OID {oid}: Brak pliku TIF w ZIP."
    tif = os.path.join(work, tifs[0])

    # 3) Pobierz extent z warstwy extentów (ZAWSZE out_fields="*")
    try:
        ext_q = _query_extent_feature(oid)
    except Exception as e:
        field_names = [f['name'] for f in extent_layer.properties.fields]
        return f"OID {oid}: Zapytanie do extentów nie powiodło się ({e}). Pola: {field_names}"

    if not ext_q or not ext_q.features or not ext_q.features[0].geometry:
        return f"OID {oid}: Brak geometrii w extentach."
    xmin, ymin, xmax, ymax = _ensure_extent_sr_3857(ext_q.features[0].geometry)

    # 4) Georeferencja/konwersja do stabilnego GeoTIFF
    final_tif_path = os.path.join(work, f"georef_{os.path.basename(tif)}")
    final_tif, _ = _embed_georef_with_tfw(tif, (xmin, ymin, xmax, ymax), final_tif_path)

    # 5) Publikacja jako Hosted Imagery Layer
    try:
        published = publish_hosted_imagery_layer(
            input_data=[final_tif],
            layer_configuration="ONE_IMAGE",
            output_name=title,
            context={"outSR": {"wkid": 102100}},
            gis=gis
        )
        viewer_url = f"https://www.arcgis.com/apps/mapviewer/index.html?layers={published.id}"
        print(f"Opublikowano Hosted Imagery Layer: {published.url}")
    except Exception as e:
        return f"OID {oid}: Błąd publikacji: {e}"

    # 6) Aktualizacja fileID
    try:
        _update_fileid_for_oid(oid, viewer_url)
        return f"OID {oid}: Sukces. Link: {viewer_url}"
    except Exception as e:
        return f"OID {oid}: Błąd aktualizacji fileID: {e}"

def main():
    try:
        feats = survey_layer.query(where="1=1", out_fields="objectid,title", return_geometry=False).features
    except Exception as e:
        print(f"❌ Błąd zapytania warstwy Survey: {e}")
        return
    for f in feats:
        try:
            print(process_feature(f))
        except Exception as e:
            print(f"❌ Błąd rekordu {f.attributes['objectid']}: {e}")

if __name__ == "__main__":
    main()
    print("\n✅ Przetwarzanie zakończone.")
